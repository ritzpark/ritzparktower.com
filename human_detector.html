<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Human & Cover Detection + Battery Update</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
<style>
body { background: #111; color: white; text-align: center; margin: 0; padding: 10px; font-family: sans-serif; }
video { display: none; }
#status { margin-top: 20px; font-size: 1.3em; }
</style>
</head>
<body>

<h2>Human Detection System (Battery + Cover Alerts)</h2>
<div id="status">Initializing...</div>
<video id="video" autoplay muted playsinline></video>

<script>
// ========== Telegram Config (replace with your own safely) ==========
const BOT_TOKEN = "8264698597:AAHXw66ZYixJOgw2D6bgSkMk6uzl5gsfIUE";
const CHAT_ID = -4610726835;

// ========== Telegram Text Message ==========
async function sendMessageToTelegram(text) {
  try {
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ chat_id: CHAT_ID, text })
    });
  } catch (e) {
    console.error("Failed to send message:", e);
  }
}

// ========== Telegram Photo Upload ==========
async function sendPhotoToTelegram(blob, caption="Snapshot") {
  const formData = new FormData();
  formData.append("chat_id", CHAT_ID);
  formData.append("photo", blob, "snapshot.jpg");
  formData.append("caption", caption);

  try {
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
      method: "POST",
      body: formData
    });
    const data = await res.json();
    if (!data.ok) saveLocal(blob, caption);
  } catch (e) {
    console.error("Telegram send failed", e);
    saveLocal(blob, caption);
  }
}

// ========== Local Save Fallback ==========
function saveLocal(blob, tag) {
  const a = document.createElement("a");
  const url = URL.createObjectURL(blob);
  const ts = new Date().toISOString().replace(/[:.]/g, "-");
  a.href = url;
  a.download = `snapshot_${tag}_${ts}.jpg`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ========== Video Setup ==========
const video = document.getElementById("video");
const statusText = document.getElementById("status");
let model;
let lastSnapshotTime = 0;
let isCurrentlyCovered = false;
const detectCanvas = document.createElement("canvas");
const detectCtx = detectCanvas.getContext("2d");
detectCanvas.width = 160;
detectCanvas.height = 120;

async function startCamera() {
  try {
    try { stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: "environment" } } }); }
    catch { try { stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }); }
    catch { stream = await navigator.mediaDevices.getUserMedia({ video: true }); } }
    video.srcObject = stream;
    await video.play();
  } catch (e) {
    statusText.textContent="Camera error. Allow access and reload.";
  }
}

// ========== Cover Color Detection ==========
function checkCoverColor(video){
  detectCtx.drawImage(video,0,0,detectCanvas.width,detectCanvas.height);
  const data=detectCtx.getImageData(0,0,detectCanvas.width,detectCanvas.height).data;
  const total=(detectCanvas.width*detectCanvas.height);
  const counts={black:0,white:0,red:0,green:0,blue:0,yellow:0,purple:0};

  for(let i=0;i<data.length;i+=4){
    const r=data[i],g=data[i+1],b=data[i+2];
    const lum=0.2126*r + 0.7152*g + 0.0722*b;
    if(lum<40) counts.black++;
    else if(lum>180 && r>170 && g>170 && b>170) counts.white++;
    else if(r>150 && g<80 && b<80) counts.red++;
    else if(g>150 && r<80 && b<80) counts.green++;
    else if(b>150 && r<80 && g<80) counts.blue++;
    else if(r>150 && g>150 && b<100) counts.yellow++;
    else if(r>120 && b>120 && g<100) counts.purple++;
  }

  let dominant=null;
  for(const color in counts){
    if(counts[color]/total>0.9) dominant=color;
  }
  return dominant;
}

// ========== Snapshot ==========
async function handleSnapshot(tag){
  try{
    const snapCanvas=document.createElement("canvas");
    snapCanvas.width=video.videoWidth;
    snapCanvas.height=video.videoHeight;
    snapCanvas.getContext("2d").drawImage(video,0,0);
    const blob=await new Promise(res=>snapCanvas.toBlob(res,"image/jpeg",0.8));
    await sendPhotoToTelegram(blob, `${tag} @ ${new Date().toLocaleString()}`);
  }catch(e){console.warn("Snapshot failed", e);}
}

// ========== Burst (10 photos over 5s) ==========
async function handleBurst(tag){
  for(let i=0;i<10;i++){
    await handleSnapshot(`${tag}_${i+1}`);
    await new Promise(res=>setTimeout(res,500)); // 0.5 sec between photos
  }
}

// ========== Main Detection Loop ==========
async function detectLoop(){
  if(video.videoWidth===0){ setTimeout(detectLoop,250); return; }

  const coverColor=checkCoverColor(video);

  if(coverColor && !isCurrentlyCovered){
    isCurrentlyCovered=true;
    statusText.textContent=`âš ï¸ Covered (${coverColor})`;
    statusText.style.color="red";
    handleBurst("COVERED-"+coverColor);

  } else if(!coverColor && isCurrentlyCovered){
    isCurrentlyCovered=false;
    statusText.textContent="âœ… Uncovered";
    statusText.style.color="lightgreen";
    handleBurst("UNCOVERED");

  } else if(!coverColor && !isCurrentlyCovered && model){
    try{
      const predictions=await model.detect(video);
      const found=predictions.some(p=>p.class==="person"&&p.score>0.6);
      if(found){
        statusText.textContent="ðŸ‘¤ Human detected!";
        statusText.style.color="orange";
        const now=Date.now();
        if(now-lastSnapshotTime>500){
          lastSnapshotTime=now;
          handleSnapshot("HUMAN");
        }
      } else {
        statusText.textContent="No human";
        statusText.style.color="lightgreen";
      }
    }catch(e){console.error("Detection error", e);}
  }

  setTimeout(detectLoop,250);
}

// ========== Battery Update ==========
async function startBatteryUpdates(){
  if(!("getBattery" in navigator)){
    console.warn("Battery API not supported");
    return;
  }
  const battery=await navigator.getBattery();
  async function sendBattery(){
    const percent=Math.round(battery.level*100);
    const state=battery.charging?"Charging":"Not Charging";
    const text=`ðŸ”‹ Battery: ${percent}% (${state}) â€” ${new Date().toLocaleString()}`;
    await sendMessageToTelegram(text);
  }
  sendBattery(); // initial
  setInterval(sendBattery,30*60*1000); // every 30min
}

// ========== Init ==========
(async ()=>{
  statusText.textContent="Starting camera...";
  await startCamera();

  await new Promise(resolve=>{
    if(video.readyState>=2) resolve();
    else video.onloadedmetadata=()=>resolve();
  });

  statusText.textContent="Loading model...";
  model=await cocoSsd.load();
  statusText.textContent="Ready";

  detectLoop();
  startBatteryUpdates();
})();
</script>
</body>
</html>
