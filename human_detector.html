<script>
// ---------- Telegram token & chat ----------
const BOT_TOKEN = "YOUR_BOT_TOKEN_HERE";
const CHAT_ID = -4610726835; // your chat id

// Save every snapshot locally as well (security)
const ALWAYS_SAVE_LOCAL = true;

// ---------- Send text to Telegram ----------
async function sendMessageToTelegram(text){
  try{
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`,{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({chat_id:CHAT_ID,text})
    });
  }catch(e){console.error("sendMessage error",e);}
}

// ---------- Send photo to Telegram ----------
async function sendPhotoToTelegram(blob,caption="Snapshot"){
  const form=new FormData();
  form.append("chat_id",CHAT_ID);
  form.append("photo",blob,"snapshot.jpg");
  form.append("caption",caption);
  try{
    const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`,{
      method:"POST",
      body:form
    });
    const data = await res.json();
    if(!data.ok) throw new Error("Telegram upload failed");
  }catch(e){
    console.warn("Upload failed, saving locally",e);
    await saveLocal(blob, caption);
  }
}

// ---------- Local save ----------
function saveLocal(blob,tag){
  return new Promise(res=>{
    const a=document.createElement("a");
    const url=URL.createObjectURL(blob);
    const ts=new Date().toISOString().replace(/[:.]/g,"-");
    a.href=url;
    a.download=`snapshot_${tag}_${ts}.jpg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setTimeout(res,500);
  });
}

// ---------- Upload Queue ----------
const uploadQueue=[];
let isProcessing=false;
const MAX_QUEUE=50;

async function processQueue(){
  if(isProcessing) return;
  isProcessing=true;
  while(uploadQueue.length>0){
    const {blob, caption} = uploadQueue.shift();
    try{
      await sendPhotoToTelegram(blob, caption);
      console.log("Uploaded:", caption, "Queue left:", uploadQueue.length);
    }catch(e){
      console.warn("Upload failed, saving locally:", caption);
      await saveLocal(blob, caption);
    }
    await new Promise(r=>setTimeout(r,800)); // cooldown
  }
  isProcessing=false;
}

// ---------- Video & Detection ----------
const video=document.getElementById("video");
const statusText=document.getElementById("status");
let model;
let lastSnapshotTime=0;
let isCurrentlyCovered=false;
let burstRunning=false;

const detectCanvas=document.createElement("canvas");
const ctx=detectCanvas.getContext("2d");
detectCanvas.width=160;
detectCanvas.height=120;

async function startCamera(){
  try{
    let stream;
    try{
      stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{exact:"environment"}}});
    }catch{
      try{
        stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
      }catch{
        stream=await navigator.mediaDevices.getUserMedia({video:true});
      }
    }
    video.srcObject=stream;
    await video.play();
  }catch(e){
    console.error(e);
    statusText.textContent="Camera error. Allow access and reload.";
  }
}

// ---------- Cover detection ----------
function checkCoverColor(video){
  ctx.drawImage(video,0,0,detectCanvas.width,detectCanvas.height);
  const data=ctx.getImageData(0,0,detectCanvas.width,detectCanvas.height).data;
  const total=detectCanvas.width*detectCanvas.height;
  const c={black:0,white:0,red:0,green:0,blue:0,yellow:0,purple:0};
  for(let i=0;i<data.length;i+=4){
    const r=data[i],g=data[i+1],b=data[i+2];
    const lum=0.2126*r+0.7152*g+0.0722*b;
    if(lum<40)c.black++;
    else if(lum>180&&r>170&&g>170&&b>170)c.white++;
    else if(r>150&&g<80&&b<80)c.red++;
    else if(g>150&&r<80&&b<80)c.green++;
    else if(b>150&&r<80&&g<80)c.blue++;
    else if(r>150&&g>150&&b<100)c.yellow++;
    else if(r>120&&b>120&&g<100)c.purple++;
  }
  for(const k in c) if(c[k]/total>0.9) return k;
  return null;
}

// ---------- Snapshot (optimized but same behavior) ----------
async function handleSnapshot(tag){
  try{
    const c=document.createElement("canvas");

    // smaller resolution to avoid freeze
    const targetWidth = 640;
    const ratio = video.videoHeight / video.videoWidth || 0.75;
    const targetHeight = Math.round(targetWidth * ratio);

    c.width=targetWidth;
    c.height=targetHeight;
    c.getContext("2d").drawImage(video,0,0,targetWidth,targetHeight);

    const blob=await new Promise(res=>c.toBlob(res,"image/jpeg",0.7));

    if(ALWAYS_SAVE_LOCAL){
      // save one local copy for security
      await saveLocal(blob, tag);
    }

    if(uploadQueue.length >= MAX_QUEUE){
      const oldest = uploadQueue.shift();
      await saveLocal(oldest.blob, oldest.caption);
    }

    uploadQueue.push({blob, caption:`${tag} @ ${new Date().toLocaleString()}`});
    processQueue();
  }catch(e){console.warn("Snapshot failed", e);}
}

// ---------- Burst: 7 photos, every 2 sec ----------
async function handleBurst(tag, count=7){
  if(burstRunning) return;
  burstRunning = true;
  // force exactly max 7
  count = Math.min(count, 7);

  try{
    for(let i=0;i<count;i++){
      await handleSnapshot(`${tag}_${i+1}`);
      await new Promise(r=>setTimeout(r,2000)); // 2 sec gap
    }
  }finally{
    burstRunning = false;
  }
}

// ---------- Detection Loop ----------
async function detectLoop(){
  if(video.videoWidth===0){
    setTimeout(detectLoop,250);
    return;
  }

  // If doing burst, skip detection to reduce load
  if(burstRunning){
    setTimeout(detectLoop,250);
    return;
  }

  const cover=checkCoverColor(video);

  if(cover && !isCurrentlyCovered){
    // Became covered â†’ 7 photos every 2 sec
    isCurrentlyCovered=true;
    statusText.textContent=`âš  Covered (${cover})`;
    statusText.style.color="red";
    handleBurst(`COVERED-${cover}`, 7);
  }else if(!cover && isCurrentlyCovered){
    // Became uncovered â†’ 7 photos every 2 sec
    isCurrentlyCovered=false;
    statusText.textContent="âœ… Uncovered";
    statusText.style.color="lightgreen";
    handleBurst("UNCOVERED", 7);
  }else if(!cover && !isCurrentlyCovered && model){
    // ðŸ”¸ Human detection: keep as before (single snapshots)
    try{
      const preds=await model.detect(video);
      const found=preds.some(p=>p.class==="person"&&p.score>0.6);
      if(found){
        statusText.textContent="ðŸ‘¤ Human detected!";
        statusText.style.color="orange";
        const t=Date.now();
        if(t-lastSnapshotTime>1500){ // 1.5s between shots (same as last version)
          lastSnapshotTime=t;
          handleSnapshot("HUMAN");
        }
      }else{
        statusText.textContent="No human";
        statusText.style.color="lightgreen";
      }
    }catch(e){console.error("Detection error",e);}
  }

  setTimeout(detectLoop,250);
}

// ---------- Battery Update ----------
async function startBatteryUpdates(){
  if(!("getBattery" in navigator)){
    console.warn("Battery API not supported");
    return;
  }
  const battery=await navigator.getBattery();
  async function sendBattery(){
    const pct=Math.round(battery.level*100);
    const state=battery.charging?"Charging":"Not Charging";
    await sendMessageToTelegram(`ðŸ”‹ Battery: ${pct}% (${state}) â€” ${new Date().toLocaleString()}`);
  }
  sendBattery();
  setInterval(sendBattery,30*60*1000);
}

// ---------- Manual capture via Telegram bot ----------
async function pollTelegram(){
  let offset = 0;
  while(true){
    try{
      const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getUpdates?offset=${offset}`);
      const data = await res.json();
      if(data.ok && data.result.length>0){
        for(const msg of data.result){
          offset = msg.update_id + 1;
          const text = msg.message?.text;
          if(text?.startsWith("/capture")){
            const parts = text.split(" ");
            const count = parseInt(parts[1])||7;
            handleBurst("MANUAL", count);
          }
        }
      }
    }catch(e){console.warn("Polling error", e);}
    await new Promise(r=>setTimeout(r,3000)); // 3 sec poll interval
  }
}

// ---------- Init ----------
(async()=>{
  statusText.textContent="Starting camera...";
  await startCamera();
  await new Promise(r=>{
    if(video.readyState>=2)r();
    else video.onloadedmetadata=()=>r();
  });
  statusText.textContent="Loading model...";
  model = await cocoSsd.load();
  statusText.textContent="Ready";
  detectLoop();
  startBatteryUpdates();
  pollTelegram();
})();
</script>
